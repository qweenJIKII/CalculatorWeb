<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="theme-color" content="#171a2b"/>
  <title>製品詳細 | 簡易電卓</title>
  <link rel="manifest" href="./manifest.webmanifest"/>
  <style>
    :root { --bg:#0f1222; --panel:#171a2b; --panel-2:#1f2340; --text:#e9ecf1; --muted:#a8b0c2; --accent:#6ea8ff; }
    html,body{height:100%}
    *,*::before,*::after{ box-sizing: border-box; }
    body{ margin:0; background: radial-gradient(1200px 600px at 10% 0%, #13173a 0%, var(--bg) 50%, #0b0e1a 100%); color:var(--text); font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans JP", sans-serif; display:flex; align-items:flex-start; justify-content:center; min-height:100dvh; padding:16px env(safe-area-inset-right) calc(16px + env(safe-area-inset-bottom)) env(safe-area-inset-left); overflow:auto; }
    .app{ width:min(980px, 100%); background:linear-gradient(180deg,var(--panel) 0%, var(--panel-2) 100%); border:1px solid rgba(255,255,255,.06); border-radius:16px; box-shadow:0 10px 30px rgba(0,0,0,.35); overflow:visible; margin:0 auto; }
    .header{ display:flex; align-items:center; justify-content:space-between; padding:14px 16px; border-bottom:1px solid rgba(255,255,255,.06); }
    .tabs{ display:flex; gap:10px; padding: 8px 14px; border-bottom:1px solid rgba(255,255,255,.06); background: rgba(255,255,255,0.02); overflow-x:auto; overflow-y:hidden; -webkit-overflow-scrolling:touch; width:100%; }
    .tab{ color: var(--muted); text-decoration: none; padding:6px 10px; border:1px solid rgba(255,255,255,.08); border-radius:8px; background: rgba(255,255,255,.02); font-size:13px; flex:0 0 auto; white-space:nowrap; }
    .tab.active{ color:var(--text); border-color: rgba(255,255,255,.18); background: rgba(255,255,255,.05); }
    .content{ padding:16px 14px 22px; display:grid; gap:14px; width:100%; }
    .card{ border:1px solid rgba(255,255,255,.08); border-radius:12px; background: rgba(255,255,255,.03); padding:14px; }
    .title2{ font-weight:700; margin-bottom:8px; }
    .row{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; width:100%; }
    .btn{ padding:10px 12px; border-radius:10px; border:1px solid rgba(255,255,255,.12); background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02)); color:var(--text); font-weight:700; cursor:pointer; }
    .muted{ color:var(--muted); font-size:12px; }
    .content > *, .row > *{ min-width:0; }
    table{ width:100%; border-collapse:collapse; }
    th, td{ text-align:left; padding:8px 10px; border-bottom:1px solid rgba(255,255,255,.08); }
    @media (max-width: 768px){ body{ padding-left: max(8px, env(safe-area-inset-left)); padding-right: max(8px, env(safe-area-inset-right)); padding-top: 12px; padding-bottom: calc(12px + env(safe-area-inset-bottom)); } .tabs{ padding: 8px 10px; } .content{ padding:12px 10px 18px; } }
  </style>
</head>
<body>
  <main class="app" aria-label="製品詳細">
    <div class="header">
      <div class="title">簡易電卓 - 製品詳細</div>
      <div class="muted">コードで検索</div>
    </div>
    <nav class="tabs" aria-label="ナビゲーション">
      <a class="tab" href="./">電卓</a>
      <a class="tab" href="./help.html">説明</a>
      <a class="tab" href="./memo.html">メモ</a>
      <a class="tab" href="./camera.html">カメラ</a>
      <a class="tab" href="./qr.html">QR</a>
      <a class="tab" href="./timer.html">タイマー</a>
      <a class="tab" href="./convert.html">換算</a>
      <a class="tab" href="./password.html">PW</a>
      <a class="tab" href="./voice.html">音声</a>
      <a class="tab" href="./music.html">音楽</a>
      <a class="tab active" href="./product.html">製品</a>
      <a class="tab" href="./calendar.html">カレンダー</a>
    </nav>

    <section class="content">
      <div class="card">
        <div class="row" style="justify-content:space-between; align-items:flex-end;">
          <div>
            <div id="name" class="title2">製品名</div>
            <div class="muted">コード: <span id="code">-</span> / ブランド: <span id="brand">-</span> / カテゴリ: <span id="category">-</span></div>
          </div>
          <div class="row">
            <button id="shareBtn" class="btn">共有</button>
          </div>
        </div>
        <p id="desc" style="margin:10px 0 0;">説明</p>
      </div>
      <div id="settingsCard" class="card">
        <div class="title2">設定</div>
        <label class="row" style="gap:8px;">
          <input id="useOnlineToggle" type="checkbox" />
          <span class="muted">オンライン補完を使用（Open * Facts）</span>
        </label>
        <label class="row" style="gap:8px;">
          <input id="saveHistoryToggle" type="checkbox" />
          <span class="muted">読み込み結果を履歴に保存</span>
        </label>
      </div>
      <div id="historyCard" class="card" style="display:none;">
        <div class="title2">履歴</div>
        <div id="historyList" class="muted"></div>
      </div>
      <div id="aiCard" class="card">
        <div class="title2">AI説明</div>
        <div class="row">
          <button id="aiLocalBtn" class="btn" type="button">ローカル要約を生成</button>
          <button id="aiLlmBtn" class="btn" type="button" title="APIキーまたはOAuthが必要（OpenAI/Gemini対応）">LLM要約を生成</button>
          <label class="row" style="gap:6px;">
            <span class="muted">プロバイダ:</span>
            <select id="aiProvider" style="padding:8px 10px; border-radius:8px; background: rgba(255,255,255,.02); color:var(--text); border:1px solid rgba(255,255,255,.12);">
              <option value="openai">OpenAI</option>
              <option value="gemini">Gemini</option>
            </select>
          </label>
          <label class="row" style="gap:6px;">
            <span class="muted">認証:</span>
            <select id="aiAuth" style="padding:8px 10px; border-radius:8px; background: rgba(255,255,255,.02); color:var(--text); border:1px solid rgba(255,255,255,.12);">
              <option value="apikey">APIキー</option>
              <option value="oauth">OAuth 2.0</option>
            </select>
          </label>
          <label id="aiKeyWrap" class="row" style="gap:6px;">
            <span class="muted">API Key:</span>
            <input id="aiKeyInput" type="password" placeholder="（保存しません）" style="width:240px;" autocomplete="off" autocapitalize="none" spellcheck="false" />
          </label>
          <label id="aiClientIdWrap" class="row" style="gap:6px; display:none;">
            <span class="muted">Client ID:</span>
            <input id="aiClientIdInput" type="text" placeholder="...apps.googleusercontent.com（保存しません）" style="width:280px;" autocomplete="off" autocapitalize="none" spellcheck="false" />
          </label>
          <div id="aiOauthWrap" class="row" style="gap:6px; display:none;">
            <button id="aiOauthBtn" class="btn" type="button">Googleで認可</button>
            <button id="aiSignOutBtn" class="btn" type="button" style="display:none;">ログアウト</button>
            <span id="aiOauthState" class="muted">未認可</span>
          </div>
          <label id="aiRememberWrap" class="row" style="gap:6px;">
            <input id="aiRememberToggle" type="checkbox" />
            <span class="muted">この端末に保存（APIキー/Client ID）</span>
          </label>
        </div>
        <div class="muted" style="margin-top:4px;">キー/トークン/Client IDは原則保存しません（保存にチェック時のみ端末に保存・トークンは保存しません）。OAuthはGemini専用・Client IDのみ使用（client_secret不要）。</div>
        <div id="aiOut" class="muted" style="margin-top:8px; white-space:pre-wrap;"></div>
      </div>
      <div id="cseCard" class="card">
        <div class="title2">対応機種（Googleカスタム検索）</div>
        <div class="row">
          <label class="row" style="gap:6px;">
            <span class="muted">API Key:</span>
            <input id="cseKeyInput" type="password" placeholder="（保存しません）" style="width:240px;" autocomplete="off" autocapitalize="none" spellcheck="false" />
          </label>
          <label class="row" style="gap:6px;">
            <span class="muted">CX (Search Engine ID):</span>
            <input id="cseCxInput" type="text" placeholder="xxxxxxxxxxxxxxxxx:yyyyyyyyyyy（保存しません）" style="width:280px;" autocomplete="off" autocapitalize="none" spellcheck="false" />
          </label>
          <button id="cseBtn" class="btn" type="button" title="JANとキーワードで検索">対応機種を取得</button>
          <label class="row" style="gap:6px;">
            <input id="cseRememberToggle" type="checkbox" />
            <span class="muted">この端末に保存（APIキー/CX）</span>
          </label>
        </div>
        <div id="cseOut" class="muted" style="margin-top:8px; white-space:pre-wrap;"></div>
      </div>
      <div id="specCard" class="card" style="display:none;">
        <div class="title2">仕様</div>
        <table id="specs"></table>
      </div>
      <div class="muted">製品データは `data/products.json` に格納されています。コードが一致する製品が見つからない場合は基本情報のみ表示します。</div>
    </section>
  </main>

  <script>
    (function(){
      const $ = (s)=> document.querySelector(s);
      const params = new URLSearchParams(location.search);
      const codeParam = (params.get('code')||'').trim();
      const code = codeParam.replace(/\s+/g,'');
      const isLikelyCode = /^\d{8}$|^\d{12}$|^\d{13}$/.test(code);
      const state = { product:null };
      const SETTINGS_KEY = 'cw_product_settings';
      const HISTORY_KEY = 'cw_product_history_v1';
      const CACHE_KEY = 'cw_product_cache_v1';
      // Optional local persistence (opt-in)
      const AI_STORE = { remember: 'cw_ai_remember', apiKey: 'cw_ai_api_key', clientId: 'cw_ai_client_id' };
      const CSE_STORE = { remember: 'cw_cse_remember', apiKey: 'cw_cse_api_key', cx: 'cw_cse_cx' };
      // OAuth session (in-memory only)
      const oauthSession = { accessToken: null, expiresAt: 0, clientId: null };
      function isTokenValid(){ return !!oauthSession.accessToken && Date.now() < oauthSession.expiresAt; }
      function setOAuthToken(token, expiresInSec){
        oauthSession.accessToken = token || null;
        const pad = 30; // refresh a bit earlier
        oauthSession.expiresAt = token && expiresInSec ? (Date.now() + Math.max(0, (expiresInSec - pad))*1000) : 0;
      }

      function render(){
        const p = state.product || { code: code || '-', name:'不明な製品', brand:'-', category:'-', description:'一致する製品が見つかりませんでした。', specs:{} };
        $('#name').textContent = p.name || '製品';
        $('#code').textContent = p.code || code || '-';
        $('#brand').textContent = p.brand || '-';
        $('#category').textContent = p.category || '-';
        $('#desc').textContent = p.description || '';
        const specs = p.specs || {};
        const specTable = $('#specs');
        specTable.innerHTML = '';
        const keys = Object.keys(specs);
        if (keys.length){
          $('#specCard').style.display = '';
          for (const k of keys){
            const v = Array.isArray(specs[k]) ? specs[k].join(', ') : (typeof specs[k]==='object' ? JSON.stringify(specs[k]) : String(specs[k]));
            const tr = document.createElement('tr');
            tr.innerHTML = `<th style="width:30%">${k}</th><td>${v}</td>`;
            specTable.appendChild(tr);
          }
        } else { $('#specCard').style.display = 'none'; }
      }

      // --- Online fetchers (fallback) ---
      function normalizeFromOFF(prod, barcode){
        if (!prod) return null;
        // Prefer Japanese fields when available
        const name = prod.product_name_ja || prod.generic_name_ja || prod.product_name || prod.generic_name || prod.product_name_en || '';
        const brand = (prod.brands || '').split(',')[0]?.trim() || '';
        const category = (prod.categories || '').split(',')[0]?.trim() || '';
        const description = prod.generic_name_ja || prod.generic_name || prod.labels || prod.packaging_text || '';
        const nutr = prod.nutriments || {};
        const specs = {};
        // Common fields
        if (prod.quantity) specs.quantity = prod.quantity;
        if (prod.packaging) specs.packaging = prod.packaging;
        if (prod.model) specs.model = prod.model;
        if (prod.color) specs.color = prod.color;
        if (Array.isArray(prod.color_tags) && prod.color_tags.length) specs.color_tags = prod.color_tags;
        if (prod.ingredients_text) specs.ingredients = prod.ingredients_text.split(/,\s*/).filter(Boolean);
        // Try to infer weight/volume from quantity string (e.g., "500 g", "1.5 L")
        try{
          const q = (prod.quantity||'').toString().toLowerCase();
          const m = q.match(/([0-9]+(?:\.[0-9]+)?)\s*(kg|g|l|ml)/i);
          if (m){
            const val = parseFloat(m[1]);
            const unit = (m[2]||'').toLowerCase();
            if (!Number.isNaN(val)){
              if (unit==='kg') specs.weight_g = Math.round(val*1000);
              else if (unit==='g') specs.weight_g = Math.round(val);
              else if (unit==='l') specs.volume_ml = Math.round(val*1000);
              else if (unit==='ml') specs.volume_ml = Math.round(val);
            }
          }
        }catch(_){/* ignore */}
        // Nutriments (mainly for foods/beverages)
        const take = (k)=> (k in nutr) ? nutr[k] : undefined;
        const nutro = {
          energy_kcal_100g: take('energy-kcal_100g'),
          proteins_100g: take('proteins_100g'),
          fat_100g: take('fat_100g'),
          carbohydrates_100g: take('carbohydrates_100g'),
          sugars_100g: take('sugars_100g'),
          salt_100g: take('salt_100g')
        };
        const nutroKeys = Object.keys(nutro).filter(k=> nutro[k] !== undefined);
        if (nutroKeys.length) specs.nutriments = nutro;
        // Tags for reference
        if (Array.isArray(prod.brands_tags) && prod.brands_tags.length) specs.brands_tags = prod.brands_tags;
        if (Array.isArray(prod.categories_tags) && prod.categories_tags.length) specs.categories_tags = prod.categories_tags;
        // Heuristics for electronics/game consoles
        const catStr = (prod.categories||'').toLowerCase();
        const labelsStr = (prod.labels||'').toLowerCase();
        const platforms = [
          { k:['nintendo switch','switch','nintendo'], v:'Nintendo Switch' },
          { k:['playstation 5','ps5'], v:'PlayStation 5' },
          { k:['playstation 4','ps4'], v:'PlayStation 4' },
          { k:['playstation 3','ps3'], v:'PlayStation 3' },
          { k:['xbox series x','xbox series s','xbox series'], v:'Xbox Series' },
          { k:['xbox one'], v:'Xbox One' }
        ];
        for (const p of platforms){ if (p.k.some(t=> catStr.includes(t))) { specs.platform = p.v; break; } }
        if (!specs.platform){ if (/xbox/.test(catStr)) specs.platform = 'Xbox'; }
        // Device type
        if (/television|tv|oled|lcd/.test(catStr)) specs.device_type = 'Television';
        else if (/camera|digital camera|dslr|mirrorless/.test(catStr)) specs.device_type = 'Camera';
        else if (/vacuum|cleaner|robot vacuum/.test(catStr)) specs.device_type = 'Vacuum Cleaner';
        else if (/refrigerator|fridge/.test(catStr)) specs.device_type = 'Refrigerator';
        else if (/washing machine|washer/.test(catStr)) specs.device_type = 'Washing Machine';
        else if (/air conditioner|ac/.test(catStr)) specs.device_type = 'Air Conditioner';
        else if (/game console|console/.test(catStr)) specs.device_type = 'Game Console';
        return {
          code: barcode,
          name: name || '(名称不明)',
          brand: brand || '-',
          category: category || '-',
          description: description,
          specs
        };
      }

      async function fetchFromOFFHost(host, barcode){
        try{
          const url = `https://${host}/api/v2/product/${encodeURIComponent(barcode)}.json`;
          const res = await fetch(url, { cache: 'no-store' });
          if (!res.ok) return null;
          const json = await res.json();
          const prod = json?.product;
          if (!prod) return null;
          return normalizeFromOFF(prod, barcode);
        }catch(_){ return null; }
      }

      // Wikidata fallback (free, CORS OK via query.wikidata.org)
      async function fetchFromWikidata(barcode){
        try{
          const code = String(barcode||'').replace(/[^0-9Xx]/g,'');
          if (!code) return null;
          const isIsbn13 = code.length===13 && /^(978|979)/.test(code);
          const q = `SELECT ?item ?itemLabel ?itemDescription ?manufacturerLabel ?instanceLabel WHERE {\n`+
                    `  { ?item wdt:P3962 "${code}". }\n`+
                    (isIsbn13 ? `  UNION { ?item wdt:P212 "${code}". }\n` : '')+
                    `  OPTIONAL { ?item wdt:P176 ?manufacturer. }\n`+
                    `  OPTIONAL { ?item wdt:P31 ?instance. }\n`+
                    `  SERVICE wikibase:label { bd:serviceParam wikibase:language \"ja,en\". }\n`+
                    `} LIMIT 1`;
          const url = 'https://query.wikidata.org/sparql?format=json&query='+encodeURIComponent(q);
          const res = await fetch(url, { headers: { 'Accept':'application/sparql-results+json' }, cache:'no-store' });
          if (!res.ok) return null;
          const json = await res.json();
          const b = json?.results?.bindings?.[0];
          if (!b) return null;
          const val = (k)=> (b[k]?.value)||'';
          const name = val('itemLabel');
          const brand = val('manufacturerLabel');
          const category = val('instanceLabel');
          const description = val('itemDescription');
          const specs = { source: 'wikidata' };
          if (val('item')) specs.wikidata_item = val('item');
          return {
            code: barcode,
            name: name || '(名称不明)',
            brand: brand || '-',
            category: category || '-',
            description: description || '',
            specs
          };
        }catch(_){ return null; }
      }

      async function fetchOnlineProduct(barcode){
        // Try multiple Open * Facts families to cover more product types (prioritize non-food for electronics)
        const hosts = [
          'world.openproductfacts.org',
          'world.openfoodfacts.org',
          'world.openbeautyfacts.org',
          'world.openpetfoodfacts.org'
        ];
        for (const h of hosts){
          const r = await fetchFromOFFHost(h, barcode);
          if (r) return r;
        }
        // Wikidata fallback (GTIN / ISBN-13)
        const wd = await fetchFromWikidata(barcode);
        if (wd) return wd;
        return null;
      }

      // --- Settings & History ---
      // Cache (full product objects)
      function loadCache(){ try{ return JSON.parse(localStorage.getItem(CACHE_KEY)||'{}')||{}; }catch(_){ return {}; } }
      function saveCache(obj){ localStorage.setItem(CACHE_KEY, JSON.stringify(obj)); }
      function getCachedProduct(code){ if (!code) return null; const c = loadCache(); return c[code] || null; }
      function cacheProduct(p){ if (!p || !p.code) return; const c = loadCache(); c[p.code] = p; saveCache(c); }

      function loadSettings(){
        try{ return JSON.parse(localStorage.getItem(SETTINGS_KEY)||'{}')||{}; }catch(_){ return {}; }
      }
      function saveSettings(s){ localStorage.setItem(SETTINGS_KEY, JSON.stringify(s)); }
      function getSettings(){
        const s = loadSettings();
        return { useOnline: s.useOnline!==false, saveHistory: s.saveHistory!==false };
      }
      function renderSettings(){
        const s = getSettings();
        const useEl = document.getElementById('useOnlineToggle');
        const saveEl = document.getElementById('saveHistoryToggle');
        if (useEl){ useEl.checked = !!s.useOnline; useEl.addEventListener('change', ()=>{ const cur=getSettings(); cur.useOnline = useEl.checked; saveSettings(cur); }); }
        if (saveEl){ saveEl.checked = !!s.saveHistory; saveEl.addEventListener('change', ()=>{ const cur=getSettings(); cur.saveHistory = saveEl.checked; saveSettings(cur); renderHistory(); }); }
      }

      function loadHistory(){ try{ return JSON.parse(localStorage.getItem(HISTORY_KEY)||'[]')||[]; }catch(_){ return []; } }
      function saveHistory(list){ localStorage.setItem(HISTORY_KEY, JSON.stringify(list)); }
      function addToHistory(p){
        if (!p || !p.code) return;
        const s = getSettings(); if (!s.saveHistory) return;
        let list = loadHistory();
        list = list.filter(x=> x.code !== p.code);
        list.unshift({ code: p.code, name: p.name||'', brand: p.brand||'', at: Date.now() });
        if (list.length>50) list = list.slice(0,50);
        saveHistory(list);
      }
      function fmtDate(ts){ try{ return new Date(ts).toLocaleString(); }catch(_){ return ''; } }
      function renderHistory(){
        const list = loadHistory();
        const card = document.getElementById('historyCard');
        const wrap = document.getElementById('historyList');
        if (!wrap || !card) return;
        if (!list.length){ card.style.display='none'; wrap.innerHTML=''; return; }
        card.style.display='';
        wrap.innerHTML = '';
        for (const item of list){
          const a = document.createElement('a');
          a.href = `./product.html?code=${encodeURIComponent(item.code)}`;
          const cached = getCachedProduct(item.code) || {};
          const nm = cached.name || item.name || '(名称不明)';
          const br = cached.brand || item.brand || '';
          a.textContent = `${item.code} — ${nm} ${br?('('+br+')'):''} / ${fmtDate(item.at)}`;
          a.style.display='block'; a.style.color='var(--text)'; a.style.textDecoration='none'; a.style.margin='4px 0';
          wrap.appendChild(a);
        }
      }
      // Persistence helpers (API Key / Client ID only)
      function applyStoredAIInputs(){
        try{
          const remember = localStorage.getItem(AI_STORE.remember) === '1';
          const rememberEl = document.getElementById('aiRememberToggle'); if (rememberEl) rememberEl.checked = remember;
          if (!remember) return;
          const keyEl = document.getElementById('aiKeyInput');
          const cidEl = document.getElementById('aiClientIdInput');
          const k = localStorage.getItem(AI_STORE.apiKey) || '';
          const c = localStorage.getItem(AI_STORE.clientId) || '';
          if (keyEl) keyEl.value = k;
          if (cidEl) cidEl.value = c;
        }catch(_){/* ignore */}
      }
      function persistAIInputsIfNeeded(){
        try{
          const remember = !!(document.getElementById('aiRememberToggle')?.checked);
          const keyEl = document.getElementById('aiKeyInput');
          const cidEl = document.getElementById('aiClientIdInput');
          if (remember){
            localStorage.setItem(AI_STORE.remember, '1');
            if (keyEl) localStorage.setItem(AI_STORE.apiKey, keyEl.value||'');
            if (cidEl) localStorage.setItem(AI_STORE.clientId, cidEl.value||'');
          }else{
            localStorage.removeItem(AI_STORE.remember);
            localStorage.removeItem(AI_STORE.apiKey);
            localStorage.removeItem(AI_STORE.clientId);
          }
        }catch(_){/* ignore */}
      }

      // CSE (Custom Search) persistence (API Key / CX only)
      function applyStoredCSEInputs(){
        try{
          const remember = localStorage.getItem(CSE_STORE.remember) === '1';
          const rememberEl = document.getElementById('cseRememberToggle'); if (rememberEl) rememberEl.checked = remember;
          if (!remember) return;
          const keyEl = document.getElementById('cseKeyInput');
          const cxEl = document.getElementById('cseCxInput');
          const k = localStorage.getItem(CSE_STORE.apiKey) || '';
          const c = localStorage.getItem(CSE_STORE.cx) || '';
          if (keyEl) keyEl.value = k;
          if (cxEl) cxEl.value = c;
        }catch(_){/* ignore */}
      }
      function persistCSEInputsIfNeeded(){
        try{
          const remember = !!(document.getElementById('cseRememberToggle')?.checked);
          const keyEl = document.getElementById('cseKeyInput');
          const cxEl = document.getElementById('cseCxInput');
          if (remember){
            localStorage.setItem(CSE_STORE.remember, '1');
            if (keyEl) localStorage.setItem(CSE_STORE.apiKey, keyEl.value||'');
            if (cxEl) localStorage.setItem(CSE_STORE.cx, cxEl.value||'');
          }else{
            localStorage.removeItem(CSE_STORE.remember);
            localStorage.removeItem(CSE_STORE.apiKey);
            localStorage.removeItem(CSE_STORE.cx);
          }
        }catch(_){/* ignore */}
      }

      // --- AI Summary (no key persistence) ---
      function getProvider(){ const el = document.getElementById('aiProvider'); return (el?.value||'openai'); }
      function getInputKey(){ const el = document.getElementById('aiKeyInput'); return (el?.value||'').trim(); }
      function productToFacts(p){
        if (!p) return {};
        return {
          code: p.code || '',
          name: p.name || '',
          brand: p.brand || '',
          category: p.category || '',
          description: p.description || '',
          price: (typeof p.price==='number'? p.price : null),
          currency: p.currency || '',
          specs: p.specs || {}
        };
      }
      function genLocalSummary(p){
        const f = productToFacts(p);
        const title = f.name || '製品';
        const brand = f.brand ? `（${f.brand}）` : '';
        const price = (f.price!=null) ? `${f.price}${f.currency||''}` : '価格情報なし';
        const feats = [];
        if (f.category) feats.push(`カテゴリ: ${f.category}`);
        if (Array.isArray(f.specs?.ingredients) && f.specs.ingredients.length) feats.push(`原材料: ${f.specs.ingredients.slice(0,6).join('、')}${f.specs.ingredients.length>6?'…':''}`);
        if (f.specs?.quantity) feats.push(`内容量: ${f.specs.quantity}`);
        if (f.specs?.color) feats.push(`色: ${f.specs.color}`);
        if (f.specs?.weight_g) feats.push(`重量: ${f.specs.weight_g}g`);
        if (f.specs?.volume_ml) feats.push(`容量: ${f.specs.volume_ml}ml`);
        if (f.specs?.nutriments){ const n=f.specs.nutriments; const nn=[]; if(n['energy_kcal_100g']!=null) nn.push(`エネルギー ${n['energy_kcal_100g']}kcal/100g`); if(n.proteins_100g!=null) nn.push(`たんぱく質 ${n.proteins_100g}g/100g`); if(n.fat_100g!=null) nn.push(`脂質 ${n.fat_100g}g/100g`); if(n.carbohydrates_100g!=null) nn.push(`炭水化物 ${n.carbohydrates_100g}g/100g`); if(n.sugars_100g!=null) nn.push(`糖類 ${n.sugars_100g}g/100g`); if(n.salt_100g!=null) nn.push(`食塩相当量 ${n.salt_100g}g/100g`); if(nn.length) feats.push(`栄養: ${nn.join(' / ')}`); }
        const desc = f.description || `${title}${brand}の概要。`;
        const lines = [
          `【説明】${desc}`,
          `【特徴】${feats.length? ('\n- '+feats.join('\n- ')):'情報が不足しています。'}`,
          `【価格】${price}`
        ];
        return lines.join('\n');
      }
      async function genOpenAISummary(p, key){
        if (!key) throw new Error('APIキーが設定されていません');
        const f = productToFacts(p);
        const prompt = `以下の製品データから、日本語で簡潔に説明(1-2文)、特徴(最大5項目の箇条書き)、価格(分かれば)を出力してください。不要な推測は避けてください。\n`+JSON.stringify(f);
        const res = await fetch('https://api.openai.com/v1/chat/completions',{
          method:'POST',
          headers:{ 'Content-Type':'application/json', 'Authorization':`Bearer ${key}`, 'Cache-Control':'no-store' },
          cache:'no-store',
          referrerPolicy:'no-referrer',
          credentials:'omit',
          mode:'cors',
          body: JSON.stringify({
            model: 'gpt-3.5-turbo',
            messages: [ { role:'system', content:'You are a concise Japanese assistant.' }, { role:'user', content: prompt } ],
            temperature: 0.2
          })
        });
        if (!res.ok) throw new Error('LLM呼び出しに失敗しました');
        const json = await res.json();
        const text = json?.choices?.[0]?.message?.content || '';
        return text.trim();
      }
      async function genGeminiSummary(p, key){
        if (!key) throw new Error('APIキーが設定されていません');
        const f = productToFacts(p);
        const prompt = `以下の製品データから、日本語で簡潔に説明(1-2文)、特徴(最大5項目の箇条書き)、価格(分かれば)を出力してください。不要な推測は避けてください。\n`+JSON.stringify(f);
        const url = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent';
        const res = await fetch(url, {
          method:'POST',
          headers:{ 'Content-Type':'application/json', 'x-goog-api-key': key, 'Cache-Control':'no-store' },
          cache:'no-store',
          referrerPolicy:'no-referrer',
          credentials:'omit',
          mode:'cors',
          body: JSON.stringify({
            contents: [ { role:'user', parts:[ { text: prompt } ] } ],
            generationConfig: { temperature: 0.2 }
          })
        });
        if (!res.ok) throw new Error('LLM呼び出しに失敗しました');
        const json = await res.json();
        const text = json?.candidates?.[0]?.content?.parts?.[0]?.text || '';
        return (text||'').trim();
      }
      async function genGeminiSummaryOAuth(p, accessToken){
        if (!accessToken) throw new Error('アクセストークンがありません');
        const f = productToFacts(p);
        const prompt = `以下の製品データから、日本語で簡潔に説明(1-2文)、特徴(最大5項目の箇条書き)、価格(分かれば)を出力してください。不要な推測は避けてください。\n`+JSON.stringify(f);
        const url = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent';
        const res = await fetch(url, {
          method:'POST',
          headers:{ 'Content-Type':'application/json', 'Authorization': `Bearer ${accessToken}`, 'Cache-Control':'no-store' },
          cache:'no-store',
          referrerPolicy:'no-referrer',
          credentials:'omit',
          mode:'cors',
          body: JSON.stringify({
            contents: [ { role:'user', parts:[ { text: prompt } ] } ],
            generationConfig: { temperature: 0.2 }
          })
        });
        if (!res.ok) throw new Error('LLM呼び出しに失敗しました');
        const json = await res.json();
        const text = json?.candidates?.[0]?.content?.parts?.[0]?.text || '';
        return (text||'').trim();
      }

      // GIS loader and token retrieval (no persistence)
      function loadGIS(){
        return new Promise((resolve, reject)=>{
          if (window.google && google.accounts && google.accounts.oauth2){ resolve(); return; }
          const s = document.createElement('script');
          s.src = 'https://accounts.google.com/gsi/client';
          s.async = true; s.defer = true;
          s.onload = ()=> resolve();
          s.onerror = ()=> reject(new Error('Google Identity Servicesの読み込みに失敗しました'));
          document.head.appendChild(s);
        });
      }
      function getGoogleAccessToken(clientId){
        return new Promise((resolve, reject)=>{
          try{
            const tokenClient = google.accounts.oauth2.initTokenClient({
              client_id: clientId,
              scope: 'https://www.googleapis.com/auth/generative-language',
              prompt: 'consent',
              callback: (resp)=>{
                if (resp && resp.access_token) resolve(resp.access_token);
                else reject(new Error('トークン取得に失敗しました'));
              }
            });
            tokenClient.requestAccessToken();
          }catch(e){ reject(e); }
        });
      }
      function getGoogleAccessTokenWithExpiry(clientId){
        return new Promise((resolve, reject)=>{
          try{
            const tokenClient = google.accounts.oauth2.initTokenClient({
              client_id: clientId,
              scope: 'https://www.googleapis.com/auth/generative-language',
              prompt: 'consent',
              callback: (resp)=>{
                if (resp && resp.access_token){ resolve({ access_token: resp.access_token, expires_in: resp.expires_in||3600 }); }
                else reject(new Error('トークン取得に失敗しました'));
              }
            });
            tokenClient.requestAccessToken();
          }catch(e){ reject(e); }
        });
      }
      async function getValidAccessToken(clientId){
        if (isTokenValid()) return oauthSession.accessToken;
        await loadGIS();
        const { access_token, expires_in } = await getGoogleAccessTokenWithExpiry(clientId);
        oauthSession.clientId = clientId;
        setOAuthToken(access_token, expires_in);
        updateOAuthStateUI();
        return oauthSession.accessToken;
      }
      async function authorizeOAuth(){
        const cid = (document.getElementById('aiClientIdInput')?.value||'').trim();
        if (!cid) throw new Error('Client IDを入力してください');
        const { access_token, expires_in } = await getGoogleAccessTokenWithExpiry(cid);
        oauthSession.clientId = cid;
        setOAuthToken(access_token, expires_in);
        updateOAuthStateUI();
      }
      async function revokeOAuth(){
        try{
          await loadGIS();
          if (oauthSession.accessToken){
            google.accounts.oauth2.revoke(oauthSession.accessToken, ()=>{});
          }
        }catch(_){ /* ignore */ }
        setOAuthToken(null, 0); oauthSession.clientId = null; updateOAuthStateUI();
      }
      function updateOAuthStateUI(){
        const wrap = document.getElementById('aiOauthWrap');
        const st = document.getElementById('aiOauthState');
        const signOut = document.getElementById('aiSignOutBtn');
        if (!wrap || !st || !signOut) return;
        if (isTokenValid()){
          const remain = Math.max(0, Math.floor((oauthSession.expiresAt - Date.now())/1000));
          st.textContent = `認可済み（残り${remain}s）`;
          signOut.style.display = '';
        }else{
          st.textContent = '未認可';
          signOut.style.display = 'none';
        }
      }

      function updateAIAuthUI(){
        const provider = getProvider();
        const auth = (document.getElementById('aiAuth')?.value)||'apikey';
        const keyWrap = document.getElementById('aiKeyWrap');
        const clientWrap = document.getElementById('aiClientIdWrap');
        const oauthWrap = document.getElementById('aiOauthWrap');
        if (provider !== 'gemini'){
          // OpenAIはAPIキーのみ
          if (keyWrap) keyWrap.style.display = '';
          if (clientWrap) clientWrap.style.display = 'none';
          if (oauthWrap) oauthWrap.style.display = 'none';
          const sel = document.getElementById('aiAuth'); if (sel) sel.value = 'apikey';
          return;
        }
        if (auth === 'oauth'){
          if (keyWrap) keyWrap.style.display = 'none';
          if (clientWrap) clientWrap.style.display = '';
          if (oauthWrap) oauthWrap.style.display = '';
          updateOAuthStateUI();
        }else{
          if (keyWrap) keyWrap.style.display = '';
          if (clientWrap) clientWrap.style.display = 'none';
          if (oauthWrap) oauthWrap.style.display = 'none';
        }
      }

      // --- Supported devices via Google Custom Search ---
      function extractDevicesFromText(text){
        try{
          const t = (text||'').replace(/\s+/g,' ').trim();
          const out = new Set();
          // 1) After "対応機種" keyword, take following chunk
          const m = t.match(/対応機種[:：]?\s*([^。\n\r]|。(?!\s*素材|\s*セット|\s*内容|\s*材質))+/);
          if (m && m[0]){
            const seg = m[0].replace(/^対応機種[:：]?\s*/,'');
            for (const token of seg.split(/[、,・/／\n\r\t]|\s{2,}/)){
              const v = token.trim();
              if (!v) continue;
              if (v.length<2 || v.length>40) continue;
              // basic allowlist of brand keywords
              if (/(iPhone|Xperia|Galaxy|Pixel|AQUOS|arrows|OPPO|Reno|HUAWEI|Xiaomi|Redmi|ZenFone|Nothing|Moto|XPERIA|GALAXY|iPad)/i.test(v)) out.add(v);
            }
          }
          // 2) Generic model patterns (window around keywords)
          const kw = ['iPhone','Xperia','Galaxy','Pixel','AQUOS','arrows','OPPO','Reno','HUAWEI','Xiaomi','Redmi','ZenFone','Nothing','Moto','iPad'];
          for (const k of kw){
            // Allow a short window of characters after the keyword (ASCII + Japanese + digits + signs + spaces)
            const r = new RegExp(k+"[\\x00-\\x7F\\u3000-\\u30FF\\u4E00-\\u9FAF0-9\\-\\+\\s]{0,30}", 'gi');
            const arr = t.match(r) || [];
            for (let s of arr){
              s = s.replace(/\s+/g,' ').trim();
              if (s.length>=3 && s.length<=40) out.add(s);
            }
          }
          return Array.from(out);
        }catch(_){ return []; }
      }
      async function searchSupportedDevicesByJAN(jan, key, cx){
        if (!jan) throw new Error('JANコードがありません');
        if (!key) throw new Error('APIキーを入力してください');
        if (!cx) throw new Error('CX(Search Engine ID)を入力してください');
        const q = `${jan} 対応機種`;
        const url = `https://www.googleapis.com/customsearch/v1?key=${encodeURIComponent(key)}&cx=${encodeURIComponent(cx)}&q=${encodeURIComponent(q)}&num=8&lr=lang_ja`;
        const res = await fetch(url, { cache:'no-store' });
        if (!res.ok){
          let msg = `検索失敗 (${res.status})`;
          try{ const j = await res.json(); if (j?.error?.message) msg = j.error.message; }catch(_){/* ignore */}
          throw new Error(msg);
        }
        const json = await res.json();
        const items = json?.items || [];
        const found = new Set();
        for (const it of items){
          const texts = [it.title||'', it.snippet||''];
          const mt = it.pagemap?.metatags || [];
          for (const tag of mt){
            if (typeof tag['og:description']==='string') texts.push(tag['og:description']);
            if (typeof tag['description']==='string') texts.push(tag['description']);
          }
          const cand = extractDevicesFromText(texts.join(' \n '));
          for (const c of cand){ found.add(c); }
        }
        return Array.from(found);
      }
      async function handleLocalSummary(){ const out = document.getElementById('aiOut'); const p = state.product; out.textContent = genLocalSummary(p); }
      async function handleLLMSummary(){
        const out = document.getElementById('aiOut');
        out.textContent = '生成中…';
        try{
          const provider = getProvider();
          const p = state.product;
          let txt = '';
          if (provider === 'gemini'){
            const authSel = document.getElementById('aiAuth');
            const mode = authSel ? authSel.value : 'apikey';
            if (mode === 'oauth'){
              const cid = (document.getElementById('aiClientIdInput')?.value||'').trim();
              if (!cid) throw new Error('Client IDを入力してください');
              out.textContent = isTokenValid()? '生成中…' : '認可中…';
              const token = await getValidAccessToken(cid);
              out.textContent = '生成中…';
              txt = await genGeminiSummaryOAuth(p, token);
            }else{
              const key = getInputKey();
              txt = await genGeminiSummary(p, key);
            }
          }else{
            const key = getInputKey();
            txt = await genOpenAISummary(p, key);
          }
          out.textContent = txt;
        }catch(e){ out.textContent = `エラー: ${e.message}`; }
      }

      async function load(){
        try{
          if (!isLikelyCode && !code){ render(); return; }
          // 0) Cache quick hit
          state.product = getCachedProduct(code) || state.product || null;
          // 1) Local DB
          try{
            const res = await fetch('./data/products.json', { cache:'no-store' });
            if (res.ok){
              const json = await res.json();
              const list = json?.products || [];
              state.product = list.find(p=> (p.code||'') === code) || state.product || null;
            }
          }catch(_){ /* ignore */ }
          // 2) Online fallback if not found locally
          const s = getSettings();
          if (!state.product && s.useOnline){
            state.product = await fetchOnlineProduct(code);
          }
        }catch(_){ state.product = null; }
        render();
        if (state.product){ cacheProduct(state.product); addToHistory(state.product); renderHistory(); }
      }

      async function share(){
        const p = state.product || { name:'製品', code };
        const url = `${location.origin}${location.pathname}?code=${encodeURIComponent(p.code||code)}`;
        const text = `${p.name} (コード: ${p.code||code})\n${p.description||''}\n${url}`;
        if (navigator.share){ try{ await navigator.share({ title:p.name, text, url }); return; }catch(_){ } }
        try{ await navigator.clipboard?.writeText(text); alert('情報をコピーしました'); }catch(_){ }
      }

      $('#shareBtn').addEventListener('click', share);
      document.getElementById('aiLocalBtn').addEventListener('click', handleLocalSummary);
      document.getElementById('aiLlmBtn').addEventListener('click', handleLLMSummary);
      document.getElementById('aiProvider').addEventListener('change', updateAIAuthUI);
      document.getElementById('aiAuth').addEventListener('change', updateAIAuthUI);
      const authBtn = document.getElementById('aiOauthBtn'); if (authBtn) authBtn.addEventListener('click', async()=>{ const out=document.getElementById('aiOut'); try{ out.textContent='認可中…'; await loadGIS(); await authorizeOAuth(); out.textContent='認可しました。'; }catch(e){ out.textContent=`エラー: ${e.message}`; } });
      const signOutBtn = document.getElementById('aiSignOutBtn'); if (signOutBtn) signOutBtn.addEventListener('click', async()=>{ const out=document.getElementById('aiOut'); try{ await revokeOAuth(); out.textContent='ログアウトしました。'; }catch(e){ out.textContent=`エラー: ${e.message}`; } });
      const rememberTgl = document.getElementById('aiRememberToggle'); if (rememberTgl) rememberTgl.addEventListener('change', persistAIInputsIfNeeded);
      const keyEl = document.getElementById('aiKeyInput'); if (keyEl) keyEl.addEventListener('input', ()=>{ persistAIInputsIfNeeded(); });
      const cidEl = document.getElementById('aiClientIdInput'); if (cidEl) cidEl.addEventListener('input', ()=>{ persistAIInputsIfNeeded(); });
      // CSE handlers
      const cseBtn = document.getElementById('cseBtn'); if (cseBtn) cseBtn.addEventListener('click', async()=>{
        const out = document.getElementById('cseOut');
        out.textContent = '検索中…';
        try{
          const jan = (state.product?.code || code || '').trim();
          const key = (document.getElementById('cseKeyInput')?.value||'').trim();
          const cx = (document.getElementById('cseCxInput')?.value||'').trim();
          const list = await searchSupportedDevicesByJAN(jan, key, cx);
          if (!list.length){ out.textContent = '対応機種は見つかりませんでした。'; }
          else { out.textContent = '対応機種:\n- ' + list.slice(0,50).join('\n- '); }
        }catch(e){ out.textContent = `エラー: ${e.message}`; }
      });
      const cseRememberTgl = document.getElementById('cseRememberToggle'); if (cseRememberTgl) cseRememberTgl.addEventListener('change', persistCSEInputsIfNeeded);
      const cseKeyEl = document.getElementById('cseKeyInput'); if (cseKeyEl) cseKeyEl.addEventListener('input', ()=>{ persistCSEInputsIfNeeded(); });
      const cseCxEl = document.getElementById('cseCxInput'); if (cseCxEl) cseCxEl.addEventListener('input', ()=>{ persistCSEInputsIfNeeded(); });
      window.addEventListener('beforeunload', ()=>{
        const remember = !!(document.getElementById('aiRememberToggle')?.checked);
        if (!remember){
          const el = document.getElementById('aiKeyInput'); if(el) el.value='';
          const el2 = document.getElementById('aiClientIdInput'); if (el2) el2.value='';
        }
        const rememberCSE = !!(document.getElementById('cseRememberToggle')?.checked);
        if (!rememberCSE){
          const k = document.getElementById('cseKeyInput'); if (k) k.value='';
          const c = document.getElementById('cseCxInput'); if (c) c.value='';
        }
      });

      // SW best-effort
      if ('serviceWorker' in navigator){ window.addEventListener('load', ()=>{ navigator.serviceWorker.register('./sw.js').catch(()=>{}); }); }
      renderSettings();
      renderHistory();
      applyStoredAIInputs();
      applyStoredCSEInputs();
      updateAIAuthUI();
      load();
    })();
  </script>
</body>
</html>
